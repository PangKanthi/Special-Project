import RepairRequestService from '../services/repairRequestService.js';
import { PrismaClient } from "@prisma/client";
import fs from 'fs';

const prisma = new PrismaClient();

export const createRepairRequest = async (req, res, next) => {
    try {
        const { problemDescription, serviceType ,firstname,lastname } = req.body;
        const userId = req.user.id;
        let addressData = req.body.address ? JSON.parse(req.body.address) : null; // üëà ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å JSON string
        let finalAddressId = req.body.addressId ? parseInt(req.body.addressId, 10) : null;

        // üìå PostgreSQL ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö String[] ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏Å‡πá‡∏ö URL ‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏õ‡πá‡∏ô Array
        const imagePaths = req.files ? req.files.map(file => `/uploads/repair_requests/${file.filename}`) : [];

        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ addressId ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏´‡∏°‡πà
        if (!finalAddressId && addressData) {
            const newAddress = await prisma.address.create({
                data: {
                    userId,
                    addressLine: addressData.addressLine,
                    province: addressData.province,
                    district: addressData.district,
                    subdistrict: addressData.subdistrict,
                    postalCode: parseInt(addressData.postalCode, 10),
                    isPrimary: false,
                    isShipping: true
                }
            });

            finalAddressId = newAddress.id;
        }

        // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• `images` ‡πÄ‡∏õ‡πá‡∏ô Array ‡πÉ‡∏ô PostgreSQL
        const repairRequest = await prisma.repair_request.create({
            data: {
                userId,
                addressId: finalAddressId,
                problem_description: problemDescription,
                service_type: serviceType,
                status: 'pending',
                images: imagePaths // üìå PostgreSQL ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö `String[]`
            }
        });
        await prisma.notification.create({
            data: {
                userId,
                message: `üõ† ‡∏°‡∏µ‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${firstname} ${lastname}`
            }
        });

        res.status(201).json({ message: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", data: repairRequest });
    } catch (error) {
        console.error("‚ùå Error creating repair request:", error);
        res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°" });
    }
};

export const getUserRepairRequests = async (req, res, next) => {
    try {
        const repairRequests = await RepairRequestService.getUserRepairRequests(req.user.id);
        res.status(200).json({ message: "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", data: repairRequests });
    } catch (error) {
        next(error);
    }
};

export const getRepairRequestById = async (req, res, next) => {
    try {
        const repairRequest = await RepairRequestService.getRepairRequestById(req.params.id);
        if (!repairRequest) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°" });

        res.status(200).json({ message: "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", data: repairRequest });
    } catch (error) {
        next(error);
    }
};

export const getAllRepairRequests = async (req, res) => {
    try {
        const allRequests = await prisma.repair_request.findMany({
            include: {
                user: true,
                address: true
            }
        });
        return res.status(200).json({ message: "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", data: allRequests });
    } catch (err) {
        return res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î" });
    }
};


export const updateRepairRequest = async (req, res, next) => {
    try {
        const { problemDescription, serviceType, status } = req.body;
        const repairRequestId = req.params.id;

        const existingRequest = await RepairRequestService.getRepairRequestById(repairRequestId);
        if (!existingRequest) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°" });

        let imageUrls = existingRequest.images;

        if (req.files && req.files.length > 0) {
            existingRequest.images.forEach(imagePath => {
                const filePath = `.${imagePath}`;
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                }
            });

            imageUrls = req.files.map(file => `/uploads/repair_requests/${file.filename}`);
        } else {
            // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ô‡∏ö => ‡∏Ñ‡∏á‡∏£‡∏π‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡πÑ‡∏ß‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°
            imageUrls = existingRequest.images;
        }

        const allowedStatuses = ['pending', 'confirm', 'complete', 'cancle'];

        const finalStatus = (status && allowedStatuses.includes(status))
            ? status
            : existingRequest.status;

        const updatedRequest = await RepairRequestService.updateRepairRequest(
            repairRequestId,
            problemDescription,
            serviceType,
            imageUrls,
            finalStatus
        );

        res.status(200).json({ message: "‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", data: updatedRequest });
    } catch (error) {
        next(error);
    }
};

export const deleteRepairRequest = async (req, res, next) => {
    try {
        const deleted = await RepairRequestService.deleteRepairRequest(req.params.id);
        if (!deleted) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°" });

        res.status(200).json({ message: "‡∏•‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
    } catch (error) {
        next(error);
    }
};

export const addPartsToRepairRequest = async (req, res, next) => {
    try {
        const { repairRequestId, parts } = req.body;
        const response = await RepairRequestService.addPartsToRepair(repairRequestId, parts);

        res.status(200).json({ message: response.message });
    } catch (error) {
        console.error("‚ùå Error adding parts to repair:", error);
        res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà" });
    }
};

